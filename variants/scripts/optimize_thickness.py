#!/usr/bin/env python3
"""Report the best-performing thickness/backing per energy and emit macro stubs."""

import argparse
from pathlib import Path

import pandas as pd

from overlay_best_thickness import (
    attach_reference_columns,
    filter_rows,
    load_reference,
    select_best_rows,
)


def write_macro(best: pd.DataFrame, output: Path, default_primaries: int) -> None:
    with open(output, "w", encoding="utf-8") as handle:
        handle.write("# Auto-generated by optimize_thickness.py\n")
        handle.write("/control/macroPath mac\n")
        handle.write("/control/execute init.mac\n\n")
        for row in best.itertuples():
            handle.write(f"# E = {row.E_keV:g} keV | foil {row.thickness_nm:g} nm | backing {row.backing_thickness_um:g} um\n")
            handle.write(f"/det/setWorldHalf {row.world_half_cm:g} cm\n")
            if getattr(row, "backing_material", ""):
                handle.write(f"/det/setBackingMaterial {row.backing_material}\n")
            handle.write(f"/det/setBackingThickness {row.backing_thickness_um:g} um\n")
            handle.write(f"/det/setWThickness {row.thickness_nm:g} nm\n")
            primaries = int(row.totalInjected) if getattr(row, "totalInjected", 0) > 0 else default_primaries
            handle.write(f"/control/alias nPrimaries {primaries}\n")
            handle.write(f"/control/alias E {row.E_keV:g}\n")
            handle.write("/control/execute e.mac\n\n")
    print(f"Macro stub written to {output}")


def main() -> None:
    parser = argparse.ArgumentParser(description="Tabulate best thickness/backing per energy and emit macros.")
    parser.add_argument("--csv", default="transmission_summary.csv", help="Path to transmission_summary.csv")
    parser.add_argument("--reference", default="nist_reference.csv", help="Path to nist_reference.csv")
    parser.add_argument("--output", default="optimized_thicknesses.csv", help="Output CSV with per-energy winners.")
    parser.add_argument("--macro-output", default=None, help="Optional macro file to emit (e.g., mac/benchmark_auto.mac)")
    parser.add_argument("--default-primaries", type=int, default=200000, help="Primaries to use when totalInjected=0.")
    parser.add_argument("--world", type=float, default=None, help="Optional world_half_cm filter.")
    parser.add_argument("--min-transmission", type=float, default=0.01, dest="min_transmission", help="Minimum T_counts.")
    parser.add_argument("--max-transmission", type=float, default=0.99, dest="max_transmission", help="Maximum T_counts.")
    parser.add_argument("--min-primaries", type=int, default=50000, dest="min_primaries", help="Minimum primaries per row.")
    parser.add_argument("--allow-clamped", action="store_true", help="Include rows that required transmission clamping.")
    parser.add_argument("--weight-mu", type=float, default=0.5, help="Weight for |Δμ/ρ| in the score.")
    parser.add_argument("--weight-muen", type=float, default=0.5, help="Weight for |Δμ_en/ρ| in the score.")
    args = parser.parse_args()

    df = pd.read_csv(Path(args.csv))
    ref_df = load_reference(Path(args.reference))
    df = attach_reference_columns(df, ref_df)
    filtered = filter_rows(df, args.min_transmission, args.max_transmission, args.min_primaries, args.allow_clamped, args.world)
    if filtered.empty:
        raise ValueError("No rows left after applying filters.")

    best = select_best_rows(filtered, args.weight_mu, args.weight_muen)
    if best.empty:
        raise ValueError("No viable winners found. Check delta columns.")
    out_path = Path(args.output)
    best.to_csv(out_path, index=False)
    print(f"Saved optimized table to {out_path}")

    if args.macro_output:
        write_macro(best, Path(args.macro_output), args.default_primaries)


if __name__ == "__main__":
    main()
